1. Fix kas_object ref() to require mutable object. 
   Since ref_loc_t::get() returns mutable, must require mutable to create.
  
2. Error to org backwards.

3. Error to skip backwards.

4. Org displays new addr w/o data. Make "skip" do same. 

5. refactor ref_loc_t / kas_object to parser

6. require kas_loc for kas_object. Change `add` methods to take loc as first arg.

7. convert m68k_arg to tagged with "is_missing" method.

8. x3/string/tst.hpp: allocs a node for a pointer type.
     XXX need data_t in x3/string/detail/tst.hpp


*********************************


Generic TGT types:

1. stmt

2. insn

3. "ARG" class requirements (empty, validate*, size*, ok_for_target)

4. fmt_*: templated with ARG_CNT & opc_*

5. reg_definitions (?). Include "ALIAS" inserter (?)

6. `opc_list`, `opc_resolved` (?)

7. insn_serialize

*********************************

*1. Why is opcode::trace not picked up in tgt_stmt::gen_insn

*2. z80:bit number serialized as immed data 

*3. local labels untagged

*4. Z80:ld (blkcnt),a -> chunk reader error.

*5. Z80: ex de,hl -> serialized incorrectly

*6. Z80: no args decoded {** INVALID **}

*7. Z80: ld hl,(blockfree) -> best not selected.

*8. Z80: ld hl,(blockfree) -> chunk reader error

*9. Z80: ld (blockfree),hl -> chunk reader error

*10. Z80: handle negative immed values (8-bit math, ix/iy offset)

*11. Z80:ld e,(hl) -> not matched

12. tgt process args: convert to begin/end. Thus vector & array are identical.
        also eliminates need to clear "de-serialize" arg vector.

*13. DATA_LEN = BLOCK_LEN - 2;  -> Needs to be evaluated as constant, not expression.

***********************************

1. M68k. refactor `m68k_size_defn` to make suitable for `target`

*2. Add `INFO` to code

*3. Complete `serialize` methods

*4. Implement default `emit`. Implement `arg` emit

5. Throw at end of adder if no `list`

6. mcode OPCODE size type calculated

7. refactor INFO to target. 

8. refactor CC to be in common: cc<cc_names, defn<{defn args...}> >

9. back-port Z80


************************************

ARM Notes:

1. implement STMT flags wrt ccode, sflag

2. implement relocation flags in TGT_EMIT

3. add ALU insns

4. add A32 insns

5. add T16 & T32 insns

6. add A64 insns

7. backport TGT mods.


****************************************

M68K Notes (m68k.input)

*1. move.l a4@-,a1@(123): DST mode not inserted (correct: 2364 007b)
 
*2. move.b #.-m_second, d4: offset incorrect

*3. move.l #m_last-m_first, d3: base value incorrectly calculated 

*4. ARM relocation name generated.

*5. "extract" is for sz, not info.

*6. stmt::print_info method, needs to be ostream support.

7. `chk:` label fails. Mimics insn name

8. fix m68k_branch arg-mode discrimination

*9. rename fmt::emit -> fmt::emit_reloc

10. remove recently added `dot_p` to insert/emit_reloc. Any code executed
    after "assembly complete" shouldn't call `fits`

11. `ident` doesn't work

*12. move with `direct:long arg` dest emits mode 7.0 (direct:short) with 4-byte arg

*13. move.l short, long: src = (symbol value .text+2), dst = globl: src mode: 7.2 (correct)
    but w/o displacement. dst_mode = 7.0 (correct is 7.1). 32-bit displacement generated
    Emits `emit: expected` error

*14. move with source pc@ generates: invalid indirect

*15. move with source pc@(d1, 123) generates : invalid addr_mode

*16. move.b #-100, d6 generates "ff9c" as arg. correct is "009c"

#17. refactor "extension" for relocations & to remove `fits` from emit.

*18. `list` needs to restore `args` before next ?

19. parse_support picks up wrong `pc`

*20. a2@(inner) & a2@(outer) both generate `symbol` reloc even `inner` is local & `outer` extern

*21. "size" still called after "assembly done". 

*22. move.l #123, a4 --> `lea`

*23. tab expansion in error message "~~~~ <<- Here" incorrect. Source tab expansion correct.

24. immed byte arg not masked to 8 bits. Modify `set_size` to
    `set_size(emit_bytes, data_size, offset)` & make `reloc` honor both base::offset & base::size. 

*25. Refactor `tgt_format` base class to be virtual. Instantiate virtual class in virtual base class. 
    override base-class members with virtual base class members.

*26. refactor `val_range` into tgt. Add <size_t> ctors

*27. refactor `validate` to take info instead of sz. refactor `tgt::arg.size() to take info.
    define `info` as separate type. include `sz` method.
    
28. move.l a2@(short), d2: shoud this be evaled as move.l pc(a2, short-(pc+2)), d2.

29. `opc::calc_size` must use & return `data.size`. why?

*30. core_fits(disp) doesn't handle fuzz correctly. fits<byte>([10, 22]) with fuzz of 109 should not be maybe.

31. frags marked `relaxed` when they're not.

32. `ref_loc_t` instances are 64 bits. need to reduce to 32 bits. probably by storing "referenced" type in
    loc map & using single 32-bit index to retrieve both.

*33. `quick` now just `fixed`. Need to generalize.

*34. refactor `tgt_data_inserter_t` to accept `chunk_type` (for chunk) & `data_type` (for arg).
    Default `data_type` to `expression::e_fixed_t`

*35. enforce `tgt_data_inserter_t`, `tgt_data_reader_t` takes size/data upto `data_type`

36. still problem with int64_t being converted to expr. Fix tgt_data_inserter unsigned short, int>

