#ifndef KAS_TARGET_TGT_DIRECTIVES_IMPL_H
#define KAS_TARGET_TGT_DIRECTIVES_IMPL_H

#include "parser/parser.h"

#include "parser/kas_token.h"
#include "parser/token_parser.h"

#include <boost/spirit/home/x3.hpp>

namespace kas::tgt::parser
{
namespace detail
{
    using namespace meta;
    using opcode = core::opcode;

    // forward declare adder
    struct tgt_directive_adder;

    // type for pseudo-op definitions
    struct tgt_directive_t
    {
        using ADDER = tgt_directive_adder;

        // XXX parameterize when working...
        using NAME_LIST = list<int_<1>>;

        using XLATE_LIST = list<list<const char *, NAME_LIST>
                              , list<tgt_dir_opcode const *, list<int_<0>>, VT_CTOR>
                              >;

        template <typename NAME, typename OPCODE, typename...Ts>
        constexpr tgt_directive_t(list<list<list<NAME>, list<OPCODE>>
                                , list<Ts...>>)
            : name_idx  { NAME::value + 1      }
            , op_idx    { OPCODE::value        }
            {}


        static inline const char           *const *names_base;
        static inline const tgt_dir_opcode *const *opcodes_base;

        const char *name() const
        {
            if (name_idx)
                return names_base[name_idx - 1];
            return {};
        }

        // implement `parser_stmt::gen_insn` for directives 
        opcode const *gen_insn(opcode::data_t& data, tgt_dir_args&& args) const
        {
            auto& op = *opcodes_base[op_idx];
            op.tgt_proc_args(data, std::move(args));
            return &op.op();
        }
        
        uint8_t name_idx;
        uint8_t op_idx;
    };

    // ADDER adds instances to directives parser
    struct tgt_directive_adder
    {
        // parser return type
        using defn_t     = tgt_directive_t;
        using VALUE_T    = tgt_directive_t const *;
        using XLATE_LIST = typename tgt_directive_t::XLATE_LIST;

        template <typename PARSER>
        tgt_directive_adder(PARSER) : insns(PARSER::sym_defns)
        {
            // expose defns from sym_parser
            using all_types_defns = typename PARSER::all_types_defns; 

            // store xlate pointers generated by `sym_parser_t`
            defn_t::names_base    = at_c<all_types_defns, 0>::value;
            defn_t::opcodes_base  = at_c<all_types_defns, 1>::value;
        }

        template <typename X3>
        void operator()(X3& x3, unsigned count) const
        {
            auto& add = x3.add;
            for (auto p = insns; count--; ++p)
                if (auto name = p->name())
                    add(name, p);
        }

        defn_t const *const insns;
    };
}



}


//
// implement tgt_stmt methods for directives
//

namespace kas::tgt::parser
{
template <typename DERIVED_T>
std::string tgt_stmt_directive<DERIVED_T>::name() const
{
    return std::string("TGT_DIRECTIVE:");// + op->name();
}

#if 0
template <typename DERIVED_T>
auto tgt_stmt_directive<DERIVED_T>::gen_insn(opcode::data_t& data)
    -> const *opcode
{
    return op->gen_insn(data, std::move(args));
}
#endif
}

#endif
