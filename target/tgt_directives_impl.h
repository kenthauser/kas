#ifndef KAS_TARGET_TGT_DIRECTIVES_IMPL_H
#define KAS_TARGET_TGT_DIRECTIVES_IMPL_H

#include "parser/parser.h"

#include "parser/kas_token.h"
#include "parser/token_parser.h"
#include "kas_core/opcode.h"

#include <boost/spirit/home/x3.hpp>

namespace kas::tgt::parser
{
namespace detail
{
    using namespace meta;
    using opcode = core::opcode;

    // forward declare adder
    struct tgt_directive_adder;

    // type for pseudo-op definitions
    struct tgt_directive_t
    {
        using ADDER  = tgt_directive_adder;
        using OPCODE = tgt_dir_opcode;

        // XXX parameterize when working...
        using NAME_LIST = list<int_<1>>;

        using XLATE_LIST = list<list<const char *, NAME_LIST>
                              , list<tgt_dir_opcode const *, list<int_<0>>, VT_CTOR>
                              >;

        template <typename NAME, typename OPCODE, typename...Ts>
        constexpr tgt_directive_t(list<list<list<NAME>, list<OPCODE>>
                                , list<Ts...>>)
            : name_idx  { NAME::value + 1      }
            , op_idx    { OPCODE::value        }
            {}


        static inline const char          *const *names_base;
        static inline const OPCODE *const *opcodes_base;

        const char *name() const
        {
            if (name_idx)
                return names_base[name_idx - 1];
            return {};
        }

        // implement `parser_stmt::gen_insn` for directives 
        opcode const *gen_insn(opcode::data_t& data, tgt_dir_args&& args) const
        {
            auto& op = *opcodes_base[op_idx];
            op.tgt_proc_args(data, std::move(args));
            return &op.op();
        }
        
        uint8_t name_idx;
        uint8_t op_idx;
    };

    // ADDER adds instances to directives parser
    struct tgt_directive_adder
    {
        // parser return type
        using defn_t     = tgt_directive_t;
        using VALUE_T    = tgt_directive_t const *;
        using XLATE_LIST = typename tgt_directive_t::XLATE_LIST;

        template <typename PARSER>
        tgt_directive_adder(PARSER) : insns(PARSER::sym_defns)
        {
            // expose defns from sym_parser
            using all_types_defns = typename PARSER::all_types_defns; 

            // store xlate pointers generated by `sym_parser_t`
            defn_t::names_base    = at_c<all_types_defns, 0>::value;
            defn_t::opcodes_base  = at_c<all_types_defns, 1>::value;
        }

        template <typename X3>
        void operator()(X3& x3, unsigned count) const
        {
            auto& add = x3.add;
            for (auto p = insns; count--; ++p)
                if (auto name = p->name())
                    add(name, p);
        }

        defn_t const *const insns;
    };
}



}


//
// implement tgt_stmt methods for directives
//

namespace kas::tgt::parser
{
template <typename DERIVED_T>
std::string tgt_stmt_directive<DERIVED_T>::name() const
{
   return std::string("TGT_DIRECTIVE:") + op->name();
   // XXX
  // using OPCODE = decltype(*op);
  // return std::declval<OPCODE>().name() + std::string(":") + op->name();
}

template <typename DERIVED_T>
auto tgt_stmt_directive<DERIVED_T>::gen_insn(opcode::data_t& data)
    -> opcode const *
{
    return op->gen_insn(data, std::move(args));
}

template <typename DERIVED_T>
template <typename Context>
void tgt_stmt_directive<DERIVED_T>::operator()(Context const& ctx)
{
    static derived_t stmt;
    auto& x3_args = x3::_attr(ctx);

    // extract "x3" args
    stmt.op       = boost::fusion::at_c<0>(x3_args);
    stmt.args     = boost::fusion::at_c<1>(x3_args);
    
    x3::_val(ctx) = &stmt;
}
}

#endif
