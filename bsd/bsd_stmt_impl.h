#ifndef KAS_BSD_BSD_STMT_IMPL_H
#define KAS_BSD_BSD_STMT_IMPL_H

#include "parser/parser.h"
#include "bsd_elf_defns.h"
#include "bsd_symbol.h"
#include "pseudo_ops_def.h"

#include "parser/kas_token.h"
#include "parser/token_parser.h"
#include "parser/annotate_on_success.hpp"

#include <boost/spirit/home/x3.hpp>

namespace kas::bsd::parser
{
namespace detail
{
    using namespace meta;

    // forward declare adder
    struct pseudo_op_adder;

    // support routines for `pseudo_op_t`
    static constexpr short to_short(const char *) { return 0; }
    template <short N>
    static constexpr short to_short(std::integral_constant<short, N>) { return N; }
    
    // type for pseudo-op definitions
    struct pseudo_op_t
    {
        // NB: 3 fixed args and index values of `byte` creates an 8-byte type
        static constexpr auto MAX_FIXED_ARGS = 3;

        using ADDER = pseudo_op_adder;

        // XXX parameterize when working...
        using NAME_LIST = list<int_<0>, int_<2>, int_<3>>;


        using XLATE_LIST = list<list<const char *, NAME_LIST>
                              , list<bsd_opcode const *, list<int_<1>>, VT_CTOR>
                              >;

        template <typename NAME, typename OPCODE, typename...ARGS
                , typename N, typename O, typename...A>
        constexpr pseudo_op_t(list<list<list<NAME, ARGS...>, list<OPCODE>>
                                 , list<N, O, A...>>)
            : name_idx  { NAME::value + 1      }
            , op_idx    { OPCODE::value        }
            , str_idx   { (ARGS::value + 1)... }
            , num_v     { to_short(A())...     }
            {}


        static inline const char       *const *names_base;
        static inline const bsd_opcode *const *opcodes_base;

        const char *name() const
        {
            return names_base[name_idx - 1];
        }

        // examine `str_idx` array to find `arg_c`. also generate `str_v`
        auto get_args() const
                -> std::pair<short, std::array<const char *, MAX_FIXED_ARGS>>
        {
            std::array<const char *, MAX_FIXED_ARGS> str_v;
            short arg_c = 0;
            do {
                auto n = str_idx[arg_c];
                if (!n)
                    break;
                str_v[arg_c++] = names_base[n-1];
            } while (arg_c < MAX_FIXED_ARGS);
            return { arg_c, str_v };
        }

        // implement `parser_stmt::gen_insn` for bsd directives 
        opcode const *gen_insn(opcode::data_t& data, bsd_args&& args) const
        {
            auto& op = *opcodes_base[op_idx];
            auto [arg_c, str_v] = get_args();
            short short_v[MAX_FIXED_ARGS];
            if (arg_c)
            {
                auto n = 0;
                for (auto p = short_v; n < arg_c;)
                    *p++ = num_v[n++];
            }
            op.bsd_proc_args(data, std::move(args), arg_c, str_v.data(), short_v);
            return &op.op();
        }
        
        uint8_t name_idx;
        uint8_t op_idx;
        uint8_t str_idx[MAX_FIXED_ARGS];
        uint8_t num_v[MAX_FIXED_ARGS];
    };

    // ADDER adds instances to directives parser
    struct pseudo_op_adder
    {
        // parser return type
        using defn_t     = pseudo_op_t;
        using VALUE_T    = pseudo_op_t const *;
        using XLATE_LIST = typename pseudo_op_t::XLATE_LIST;

        template <typename PARSER>
        pseudo_op_adder(PARSER) : insns(PARSER::sym_defns)
        {
            // expose defns from sym_parser
            using all_types_defns = typename PARSER::all_types_defns; 

            // store xlate pointers generated by `sym_parser_t`
            defn_t::names_base    = at_c<all_types_defns, 0>::value;
            defn_t::opcodes_base  = at_c<all_types_defns, 1>::value;
        }

        template <typename X3>
        void operator()(X3& x3, unsigned count) const
        {
            auto& add = x3.add;
            for (auto p = insns; count--; ++p)
                add(p->name(), p);
        }

        pseudo_op_t const *const insns;
    };

    // since two types of `bsd_directives` share a common implentation type
    // (`pseudo_op_t`), need to combine string & opcode definitions into a single
    // translation list (strings->index, opcodes->index). Pass this list
    // to the actual parser generator

    // combine bsd-directive sub-definitions
    using comma_defs = all_defns<comma_ops_v, bsd_pseudo_tags>;
    using space_defs = all_defns<space_ops_v, bsd_pseudo_tags>;

    using all_bsd_directives = concat<space_defs, comma_defs >;
    using xlate_types = typename sym_parser_t<pseudo_op_t
                                            , all_bsd_directives
                                            >::all_types;

    static const auto comma_ops = parser::sym_parser_t<pseudo_op_t
                                                    , comma_defs
                                                    , void
                                                    , xlate_types
                                                    >();
    static const auto space_ops = parser::sym_parser_t<pseudo_op_t
                                                    , space_defs
                                                    , void
                                                    , xlate_types
                                                    >();
}



}

namespace kas::bsd::parser::bnf
{
auto const comma_op_def = no_case[lexeme['.' >> detail::comma_ops.x3()]];
auto const space_op_def = no_case[lexeme['.' >> detail::space_ops.x3()]];
BOOST_SPIRIT_DEFINE(comma_op, space_op)
}

//
// implement bsd_stmt methods for pseudo-ops
//

namespace kas::bsd
{
std::string bsd_stmt_pseudo::name() const
{
    return std::string("BSD_PSEUDO:") + op->name();
}

opcode const *bsd_stmt_pseudo::gen_insn(opcode::data_t& data)
{
    return op->gen_insn(data, std::move(v_args));
}

void bsd_stmt_pseudo::print_args(kas::parser::print_obj const& fn) const
{
    // if fixed args, copy to container & pass separately
    auto [arg_c, str_v] = op->get_args();
    if (arg_c)
    {
        // copy `arg_c` strings to `xtra_args` vector
        std::vector<const char *> xtra_args(&str_v[0], &str_v[arg_c]);
        fn(xtra_args, v_args);
    }
    else
        fn(v_args);
}
    
}

#endif
