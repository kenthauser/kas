#ifndef KAS_ARM_ARM_PARSER_H
#define KAS_ARM_ARM_PARSER_H

//////////////////////////////////////////////////////////////////////////
//
// Parse ARM instructions using unified syntax
//
// ARM argument formats:
//
// direct:     label
//
// immed:      # immed
//
// const shift:  {LSL, ROR} #<n>  (1 << n << 31)
//             | {LSR, ASR} #<n>  (1 << n << 32)
//             | RRX
// 
// reg shift:    {ASR, LSL, LSR, ROR} Rs
//
// reg:        Rn
//
// reg_update: Rn!
//
// reg_offset: [Rn, offset]
// pre-index:  [Rn, offset]! (ie offset with write-back)
// post-index: [Rn], offset  (ie offset is next arg & is written back)
//
// NB: offset == #{+/-} immed
//            | {+/-} <Rm>
//            | {+/-} <Rm> {, shift}
//
// MISC: some instructions (such as `SETEND`) have special named args. These
//       are supported by directly analyzing "tokens" generated by assembler.
//
//////////////////////////////////////////////////////////////////////////

#include "arm_parser_types.h"
#include "arm_parser_support.h"

#include "expr/expr.h"              // expression public interface
#include "parser/annotate_on_success.hpp"
#include "parser/token_parser.h"

#include <boost/spirit/home/x3.hpp>
#include <boost/fusion/include/std_pair.hpp>

namespace kas::arm::parser
{
namespace x3 = boost::spirit::x3;
using namespace x3;
using namespace kas::parser;

// X3 parser rules: convert "parsed" args to location-stampped args

// NB: X3 only performs type conversions via ctors with single args.
// However, including 'boost/fusion/std_pair.hpp" allows pairs to be parsed
// Thus, parse args as "expr / mode" pair & pass that to `arg_t` ctor

//x3::rule<class _,   expr_t> parse_regset = "arm_parse_regset";


struct token_reg : kas_token
{
    operator arm_reg_t const&() const
    {
        return value;
    }

    arm_reg_t value;
};

struct token_expr : kas_token
{
    token_expr(expr_t const &e = {}) : value(e) {}

    operator expr_t const&() const
    {
        return value;
    }

    expr_t value;
};

auto const reg_tok = token<token_reg>[arm_reg_x3()];

// `token` parser implies `lexeme`. Manually tag expr token.
auto const expr_tok = rule<class _tag_expr, token_expr> {} = expr();
struct _tag_expr : kas::parser::annotate_on_success {};

//
// Parse `shift` arg
//

// SHIFT: slightly complicated parser to prevent back-tracking
auto const parse_shift = rule<class _, arm_shift_arg> {"parse_shift"}
        = lit("lsl") > (('#' > expr_tok) [arm_shift_arg(ARM_SHIFT_LSL)]
                        | reg_tok        [arm_shift_arg(ARM_SHIFT_LSL)])
        | lit("lsr") > (('#' > expr_tok) [arm_shift_arg(ARM_SHIFT_LSR)]
                        | reg_tok        [arm_shift_arg(ARM_SHIFT_LSR)])
        | lit("asr") > (('#' > expr_tok) [arm_shift_arg(ARM_SHIFT_ASR)]
                        | reg_tok        [arm_shift_arg(ARM_SHIFT_ASR)])
        | lit("ror") > (('#' > expr_tok) [arm_shift_arg(ARM_SHIFT_ROR)]
                        | reg_tok        [arm_shift_arg(ARM_SHIFT_ROR)])
        | lit("rrx") >  attr(token_expr()) [arm_shift_arg(ARM_SHIFT_RRX)]
        ;

//
// Parse `indirect` arg
//

// helpers for `parse_indir_terms`
// get_sign: -{+/-} -> '+' or (omitted) => 0, '-' => 1
auto get_sign = rule<class _, int> {}
                = lit('-') > attr(1)
                | lit('+') > attr(0)
                | attr(0)
                ;
// get_write_back: {!} -> (omitted) => 0, '!' => 1
auto get_write_back = rule<class _, int> {}
                = lit('!') > attr(1)
                | attr(0)
                ;

auto const parse_indir_terms = rule<class _, arm_indirect_arg> {"indir_terms"}
        // post-indexed
        = (']' >> (',' > (('#' > get_sign > expr_tok > attr(1))
                                            [arm_indirect_arg(ARM_POST_INDEX)]
                          |(get_sign > reg_tok > -(lit(','), parse_shift) > attr(1))
                                            [arm_indirect_arg(ARM_POST_INDEX)]
                          )))

        // reg-update
        | (']' >> ('!' > attr(arm_indirect_arg(ARM_INDIR_REG_WB))))

        // reg-indirect
        | (']'         > attr(arm_indirect_arg(ARM_INDIR_REG)))

        // pre-indexed, immed
        | (',' >> ('#' > get_sign > expr_tok > ']' > get_write_back))
                    [arm_indirect_arg(ARM_PRE_INDEX)]

        // pre-indexed, reg
        | (',' >> (get_sign > reg_tok > -(lit(','), parse_shift) > ']' > get_write_back))
                    [arm_indirect_arg(ARM_PRE_INDEX)]
        ;
       
// add base register to `indir` value
auto add_base_reg = [](auto& ctx)
    {
        auto& args  = x3::_attr(ctx);
        auto& base  = boost::fusion::at_c<0>(args);
        auto& indir = boost::fusion::at_c<1>(args);
        indir.base_reg = base;
        x3::_val(ctx)  = indir;
    };

auto const parse_indir = rule<class _, arm_indirect_arg> {"parse_indirect"}
        = (reg_tok > parse_indir_terms)[add_base_reg];
        
       
//
// Parse `register-set arg`
//

// allocate `regset` from first `reg`
auto regset_init = [](auto& ctx) 
        { 
            auto& regset  = arm_reg_set::add(x3::_attr(ctx));
            x3::_val(ctx) = regset.ref();
        };

// add another term to regset
auto regset_add = [](char op)
        {
            return [op=op](auto& ctx) 
                {
                    x3::_val(ctx).get().binop(op, x3::_attr(ctx));
                };
        };

// must use `ref` because `arm_regset` is KAS_OBJECT & can't be copied nor moved
auto const parse_regset = rule<class _, arm_rs_ref> {} =
        arm_reg_x3()[regset_init] >> (',' > arm_reg_x3())[regset_add('/')]
                                    |('-' > arm_reg_x3())[regset_add('-')]
        ; 

auto const arg_regset = parse_regset > '}' > attr(MODE_REGSET);

//
// Parse simple arguments into `expr/MODE` pair
//
// Direct, Immediate, Register-set
//

using arm_parsed_arg_t = std::pair<expr_t, arm_arg_mode>;
auto const simple_parsed_arg = rule<class _, arm_parsed_arg_t> {"arm_parsed_arg"}
        = (expr() > (('!' > attr(MODE_REG_UPDATE))
                     |      attr(MODE_DIRECT)
                     ))
        | ('#' > expr()   > attr(MODE_IMMEDIATE))
        | ('{' > arg_regset)
        ;

//
// include more complex parsed args 
//
auto const raw_parsed_arg = rule<class _, arm_arg_t> { "raw_parsed_arg" }
       = simple_parsed_arg
       | '[' > parse_indir
       | parse_shift
       ;

// convert "parsed pair" into arg via `tgt_arg_t` ctor
x3::rule<class _tag_arm_arg, arm_arg_t>  arm_arg        = "arm_arg";
x3::rule<class _tag_missing, arm_arg_t>  arm_missing    = "arm_missing";

auto const arm_arg_def     = raw_parsed_arg;
auto const arm_missing_def = eps;      // need location tagging


BOOST_SPIRIT_DEFINE(arm_arg, arm_missing)

// an arm instruction is "opcode" followed by comma-separated "arg_list"
// "no arguments" -> location tagged, default contructed `arm_arg`
auto const arm_args = rule<class _, std::vector<arm_arg_t>> {"arm_args"}
       = arm_arg % ','              // allow comma seperated list of args
       | repeat(1)[arm_missing]     // no args: MODE_NONE, but location tagged
       ;

// need two rules to get tagging 
auto const raw_arm_stmt = rule<class _, arm_stmt_t> {} = 
                    (arm_insn_x3() > arm_args)[arm_stmt_t()];

// Parser interface
arm_stmt_x3 arm_stmt {"arm_stmt"};
auto const arm_stmt_def = raw_arm_stmt;

BOOST_SPIRIT_DEFINE(arm_stmt)

// tag location for each argument
struct _tag_arm_arg  : kas::parser::annotate_on_success
    {
        using base_t = kas::parser::annotate_on_success;
        template <typename...Ts>
        void on_success(Ts&&...ts)
        {
            std::cout << "tagging" << std::endl;
            base_t::on_success(std::forward<Ts>(ts)...);
        }
    };
struct _tag_missing  : kas::parser::annotate_on_success {};
struct _tag_arm_stmt : kas::parser::annotate_on_success {}; 
}

#endif
