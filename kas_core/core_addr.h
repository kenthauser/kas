#ifndef KAS_CORE_CORE_ADDR_H
#define KAS_CORE_CORE_ADDR_H

/*
 * core_addr
 *
 * A `core_addr` object is used to identify a location in the object
 * code stream generated by the assembler.
 *
 * A `core_addr` is a `core_object` object. Thus `core_addr` instances
 * are allocated as the source is parsed (or dwarf program generated),
 * and are never destroyed.
 *
 * `core_addr` instances can be accessed via `core_object` index.
 *
 * A pointer to a `core_addr` object is located in a `core_symbol` object,
 * or as a delta in a `core_expr` expression (most often for dwarf data).
 *
 * The `core_addr` object contains a "fragment pointer" to the `core_fragment` 
 * which holds the address, and an "offset pointer" with identifies a 
 * location within the fragment.
 *
 * The implementation uses the "fixed" data portion of a "label" instruction
 * located in the fragment to hold the "offset pointer". The values in this
 * instruction's fixed area are updated during the relax of the fragment.
 *
 * `core_addr` objects are most commonly geneated by "label" instructions.
 * A `core_addr` object is not necessarily created for each label. For instance,
 * multiple labels at the same location with only generate a single `opc_label`.
 * The others will be "nops".
 *
 * `core_addr` objects may also be geneated by branches (using "DOT_AFTER") and
 * dwarf instructions which want object deltas "after" size value. These
 * `core_addr` objects are also generated using `get_dot(DOT_AFTER)`.
 * 
 */

#include "core_terminal_types.h"
#include "kas_object.h"
#include "core_fragment.h"

namespace kas::core
{


// use `core_object` to manage instances
template <typename REF>
struct core_addr : kas_object<core_addr<REF>, REF>
{
    using base_t = kas_object<core_addr<REF>, REF>;

    
    using NAME = KAS_STRING("core_addr");

    enum { DOT_CUR, DOT_NEXT };

    // XXX for `expr_fits`
    using emits_value = std::true_type;

    using base_t::add;
    using base_t::dump;

    core_addr() = default;
    core_addr(core_fragment const *frag_p, frag_offset_t const *offset_p)
        : frag_p(frag_p), offset_p(offset_p) {}


    core_fragment const *frag_p   {};
    frag_offset_t const *offset_p {};

    frag_offset_t        offset()  const;
    core_section  const& section() const;

    // bool true iff `core_addr` is uninitialized
    // XXX should `frag_p` be set a generation?
    // XXX `offset_p` might be better for "empty"
    bool empty() const { return !frag_p; }

    bool operator<(core_addr const& o) const
    {
        // return "not greater-equal"
        {
#if 0
        return (frag_p >= o.frag_p)
                || offset_p->min >= o.offset_p->min);
#else

        //bool result_frag = !(*frag_p < *o.frag_p);
        bool result_frag = frag_p->operator<(*o.frag_p);
        bool result_off  = offset_p->max < o.offset_p->max;

//        std::cout << std::endl;
//        std::cout << "[addr< frag = " << std::boolalpha << result_frag;
//        std::cout << ", offset = " << result_off << "] ";
    
        if (frag_p == o.frag_p)
            return result_off;
        return result_frag;
#endif
        }
    }

    //
    // Routines which allocate addresses
    // (default ctor) returns dummy address
    //

    static core_addr& get_dot(int which = DOT_CUR)
    {
        auto dot_p = (which == DOT_NEXT) ? &next_dot : &current_dot;

        if (!*dot_p)
            *dot_p = &add();

        //std::cout << __FUNCTION__ << ": dot = " << *dot_p << std::endl;;
        return **dot_p;
    }

    //
    // methods used by `insn_container` to allocate
    // label instructions
    //

    static auto& cur_dot()
    {
        if (!current_dot)
            current_dot = &add();
        return *current_dot;
    }

    static void new_dot()
    {
        current_dot = next_dot;
        next_dot = {};
    }

    // for insn_inserter: was dot referenced
    static bool must_init_dot()
    {
        return current_dot && current_dot->empty();
    }

    auto& init_addr(core_fragment const *frag_p, frag_offset_t const* offset_p)
    {
        this->frag_p   = frag_p;
        this->offset_p = offset_p;
        return *this;
    }

    friend std::ostream& operator<< (std::ostream& os, core_addr const& addr)
    {
        addr.print(os);
        return os;
    }
    template <typename OS> void print(OS& os) const;
   
    // re-init statics for test fixture (via `kas_clear`)
    static void clear()
    {
        current_dot = {};
        next_dot    = {};
    }

private:
    friend std::ostream& operator<< (std::ostream&, const core_addr&);
    static inline core_addr *current_dot;
    static inline core_addr *next_dot;
};

// with core_fragment defined, implement core_addr method
template <typename REF>
inline frag_offset_t core_addr<REF>::offset() const
{
    auto offset = frag_p->base_addr();
    if (offset_p)
        offset += *offset_p;
    return offset;
}

template <typename REF>
inline core_section const& core_addr<REF>::section() const
{
    return frag_p->segment().section();
}

inline bool core_fragment::operator<(core_fragment const& other) const
{
    // primary (only?) use of operator< is for `seen_this_pass`.
    // since relax a segment at a time, not-looking is same as has-seen.
    if (segment() != other.segment())
        return true;
    auto result = frag_num() < other.frag_num();
//    std::cout << "\n[frag< " << frag_num() << " < " << other.frag_num();
//    std::cout << " -> " << std::boolalpha << result << "] ";
    return frag_num() < other.frag_num();
}

template <typename REF>
template <typename OS>
void core_addr<REF>::print(OS& os) const
{
    // generate a single emit to OS (for formatting)
    std::ostringstream str;
    str << "ca(";
    if (!frag_p) {
        str << "[dot]";      // only `addr` w/o frag is dot.
    } else if (*frag_p && offset_p) {
        auto n = frag_p->base_addr().max + offset_p->max;
        str << frag_p->section() << "+" << std::hex << n;
    } else {
        str << frag_p->segment();
    }
    str << ")";

    os << str.str();
}

}
#endif
