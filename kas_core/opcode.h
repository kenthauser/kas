#ifndef KAS_CORE_OPCODE_H
#define KAS_CORE_OPCODE_H

///////////////////////////////////////////////////////////////////////////
//
//                          o p c o d e s
//
///////////////////////////////////////////////////////////////////////////
//
// The opcodes class provides the interface between the parser and the
// object-code generation modules of the assembler.
//
// In order to provide a consistent interface, an `opcode` generated by the
// parser includes a single fixed arguemnt (normally uint32_t), and a
// sequence of `expr_t` types. To facilitate storing a sequence of the
// `opcodes` in the object code table, the `expr_t` expressions are
// normalized as followes: the `expr_t` sequence is copied into a
// static `opcodes` deque, and a `start, count` pair is generated.
// Thus, the data for an opcode consists of a tuple {fixed, start, count}.
//
///////////////////////////////////////////////////////////////////////////
//
// The opcode format uses CRTP instead of virtual functions to facilitate
// conversions to/from the raw `opcode_data` stored in the instruction
// list & the operations. If virtual functions were used for polymorphism,
// the `vtable` would interfere with converting raw data to a type.
//
// The CRTP form requires a little more typing, some pointer-to-member
// function calls, and using `this->derived()` when generally a name would
// do. But otherwise the functionality is the same.
//
///////////////////////////////////////////////////////////////////////////

#include "core_size.h"
#include "core_emit.h"
#include "insn_data.h"
#include "core_fits.h"

#include "kas_object.h"
#include "utility/string_mpl.h"

#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>
#include <deque>
#include <typeinfo>
#include <typeindex>



namespace kas::core::opc
{

using kas_error_t = parser::kas_error_t;
using kas_diag    = parser::kas_diag;

#define OPC_INDEX()   \
    uint16_t& opc_index() const override            \
    {  static uint16_t index_; return index_; }     \
    uint16_t opc_size() const override { return sizeof(*this); }

template <typename DATA>
struct insn_opcode
{
    // all opcode configurable types are bundled into `DATA`
    using data_t     = DATA;
    using value_type = typename DATA::value_type;
    using Iter       = typename DATA::Iter;
    using Inserter   = typename DATA::Inserter;

    using fixed_t    = typename DATA::fixed_t;
    using op_size_t  = typename DATA::op_size_t;


    // must init base opcode via base ctor.
    insn_opcode(fixed_t fixed = {}, op_size_t size = {})
        : ctor_fixed(fixed), ctor_size(size) {}

    virtual ~insn_opcode() = default;

    virtual insn_opcode& init(fixed_t& fixed, op_size_t& size)
    {
        this->fixed_p = &fixed;
        this->size_p  = &size;
        return *this;
    }

    // declare virtual functions for evaluating opcodes
    virtual const char *name() const
    {
        return typeid(*this).name();
    }
    virtual op_size_t calc_size(Iter iter, uint16_t cnt, core_fits const& fits)
    {
        return *size_p;
    }
    virtual void fmt(Iter iter, uint16_t cnt, std::ostream& out)
    {}
    virtual void emit(Iter iter, uint16_t cnt, emit_base& base, core_expr_dot const& dot)
    {}

private:
    virtual uint16_t& opc_index() const = 0;
    virtual uint16_t  opc_size()  const = 0;

    static constexpr uint16_t V_OPCODE_SZ = 64;
    struct V_OPCODE
    {
        V_OPCODE(insn_opcode const *p)
        {
            auto n = p->opc_size();
            if (n > V_OPCODE_SZ)
                throw std::length_error(p->name() +
                    std::string(" = ") + std::to_string(n));
            std::memcpy(data, (void *)p, n);
        }
        
        operator insn_opcode *()
        {
            return reinterpret_cast<insn_opcode *>(data);
        }

        uint8_t data[V_OPCODE_SZ];
    };
    
    static auto& opc_indexes ()
    {
        static auto _indexes = new std::deque<V_OPCODE>;
        return *_indexes;
    }

    static uint16_t add_index(insn_opcode *p)
    {
        auto& indexes = opc_indexes();
        indexes.emplace_back(p);
        return indexes.size();
    }
public:
    uint16_t index()
    {
        auto& idx = opc_index();
        if (idx == 0)
            idx = add_index(this);
        return idx;
    }
    
    static auto& get(uint16_t n)
    {
        return *opc_indexes()[n - 1];
    }

    // if no arguments -- presumably result stored in fixed.
    void proc_args(Inserter&) {}

    // routine for test runner
    void raw(Iter iter, uint16_t cnt, std::ostream& out)
    {
        out << std::dec << this->name() << ": " << *size_p;
        out << std::hex << ' ' << fixed_p->fixed << ' ';
        while(cnt--)
            out << *iter++ << ' ';
    }

    // declare methods for creating opcodes
    template <typename C> 
    kas_error_t validate(C&) { return {}; }

    template <typename C>
    kas_error_t validate_min_max(C&, uint16_t = 0, uint16_t = ~0);

#if 0
    void make_error(parser::kas_diag const *err)
    {
        // picked up by `core_insn` & converted to error opcode
        fixed_p->diag = err->ref();
        size_p->set_error();
    }
#endif
    
    void make_error(parser::kas_error_t err)
    {
        fixed_p->diag = err;
        size_p->set_error();
    }

    // convenience method: pass msg & `loc`
    void make_error(const char *msg, kas::parser::kas_loc const& loc)
    {
        return make_error(kas_diag::error(msg).ref(loc));
    }

    void make_error(std::string const& msg, kas::parser::kas_loc const& loc)
    {
        return make_error(msg.c_str(), loc);
    }
    
    // convenience method: pass msg & `ref`
    template <typename T, typename U>
    void make_error(const char *msg, ref_loc_t<T, U> const& ref)
    {
        return make_error(msg, *ref.template get_p<kas_loc>());
    }

private:
    // used when opcode inited via ctor
    fixed_t   ctor_fixed;
    op_size_t ctor_size;

public:
    fixed_t   *fixed_p {&ctor_fixed};
    op_size_t *size_p  {&ctor_size };
    static inline std::ostream *trace;
};

// create alias using default types
using opcode = insn_opcode<>;

template <>
template <typename C>
kas_error_t opcode::validate_min_max(C& c, uint16_t min, uint16_t max)
{
    
    // single arg can be "missing" or real arg.
    // clear container if "missing"
    if (c.size() == 1)
        if (c.front().is_missing()) {
            if (min == 1)
                return kas_diag::error("Requires argument").ref(c.front());
            else if (!min) {
                c.clear();
                return {};
            }
        }

    if (c.size() < min)
        return kas_diag::error("Too few arguments").ref(*std::prev(c.end()));

    if (c.size() > max) {
        auto last = c.begin();
        std::advance(last, max);
        return kas_diag::error("Too many arguments").ref(*last);
    }

    return {};
}

template <typename NAME = KAS_STRING("NOP")>
struct opc_nop : opcode
{
    OPC_INDEX();
    const char *name() const override
    {
        return NAME::value;
    }

};

struct opc_error : opcode
{
    OPC_INDEX();
    const char *name() const override
    {
        return "ERROR";
    }

    void proc_args(Inserter& di, kas::parser::kas_error_t diag)
    {
        fixed_p->diag = diag;
    }

    void fmt(Iter iter, uint16_t cnt, std::ostream& out) override
    {
        out << name() << ": ";
        out << (fixed_p->diag ? fixed_p->diag.get().message : "[[ Zero Errno ]]");
    }

    void emit(Iter iter, uint16_t cnt, emit_base& emit, core_expr_dot const& dot) override
    {
        if (fixed_p->diag)
            emit << emit_info << fixed_p->diag.get();
    }
};
}

// copy "opcode" into kas::core

namespace kas::core
{
    //using opcode = typename opc::opcode;
    using opc::opcode;
}

#endif
