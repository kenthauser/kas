#ifndef KAS_PARSER_TOKEN_DEFN_H
#define KAS_PARSER_TOKEN_DEFN_H

//#include "kas_token.h"
#include "kas/kas_string.h"     // for "NAMES" of tokens

namespace kas::parser
{

// `token_defn` is an abstract base class used to specialize `kas_token` instances
// to convert the parsed "integer" & "raw" types as required.
//
// `token_defn` has no instance data & is essentially a way to access a "VTABLE".
// Since `token_defn` instances & derived instances are generally created as rvalues
// (ie not permanently allocated), the instance value can't be stored for future refernce.
// Accordingly, the virtual method `get` is defined which returns a reference to a 
// statically created instance of derived type.

struct token_defn_base
{
    // get reference to static instance of derived type
    virtual token_defn_base const& get() const = 0;

    // get token name
    virtual const char *name() const = 0;
    
    // calculate "expr" from token's "raw" and/or "expr" values
    // default: don't modify `kas_token` expr value
    virtual void gen_expr(expr_t& e, kas_token const&) const {};
    
    // test if token is particular type
    token_defn_base const *is_token_type(std::type_info const& info) const
    {
        // NB: warning generated by `typeid(get())`
        auto&& t = get();
        return info == typeid(t) ? this : nullptr;
    }
};

// XXX new comment
// `token_defn_t` is currently a "final" type (eg: `get` method *must* be overridden)
// could be better if it was a CRTP base.
// NB: currently `gen_expr` overrides take place in `kas::parser` namespace. 
// Deriving from `token_defn_t` required redefining `get()` method: likely error.

// declared in `parser_types.h`
template <typename NAME, typename VALUE_T = x3::unused_type, typename PARSER = void>
struct token_defn_t : token_defn_base
{
    using base_t   = token_defn_base;
    using name_t   = NAME;
    using value_t  = VALUE_T;       // NB: default if `unused_type`
    using parser_t = PARSER;

    struct token_defn_parser
    {
        template <typename T>
        token_defn_parser(T parser)
        {
            auto p = x3::as_parser(parser);

        }
    };

    // true iff can generate `parser` from `token_defn_t`
    using has_parser = meta::bool_<!std::is_void_v<VALUE_T> && !std::is_void_v<PARSER>>;

    base_t const& get() const override
    {
        // NB: `NAME` is not "literal type" per clang, thus not constexpr
        static const token_defn_t defn;
        return defn;
    }

    const char *name() const override
    {
        return NAME();
    }
    
    // specialize template out-of-line to supply non-default method
    // alternatively: derive subclass & "override"
    // NB: subclass normally needs to "override" `get` as well.
    void gen_expr(expr_t& e, kas_token const& pos) const override {}
};

}

#endif
