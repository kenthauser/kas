#ifndef KAS_PARSER_TOKEN_DEFN_H
#define KAS_PARSER_TOKEN_DEFN_H

//#include "kas_token.h"
#include "kas/kas_string.h"     // for "NAMES" of tokens
#include "kas_core/kas_object.h"

#include <typeinfo>

namespace kas::parser
{

// `token_defn` is an abstract base class used to specialize `kas_token` instances
// to convert the parsed "integer" & "raw" types as required.
//
// `token_defn` has no instance data & is essentially a way to access a "VTABLE".
// Since `token_defn` instances & derived instances are generally created as rvalues
// (ie not permanently allocated), the instance value can't be stored for future refernce.
// Accordingly, the virtual method `get` is defined which returns a reference to a 
// statically created instance of derived type.

struct token_defn_base
{
    // get reference to static instance of derived type
    virtual token_defn_base const& get() const = 0;

    // initialize `kas_token` instance for `token_defn` object
    virtual void const *init(std::type_info const&, void const *obj) const
    {
        std::cout << "token_defn_base::init: default" << std::endl;
        print_type_name{"token_defn"}(*this);
        return obj;
    }

    // get token name
    virtual const char *name() const = 0;
    
    // get expression value `index`
    virtual unsigned index() const = 0;
    
    // declare method to generate `data_p` for tokens
    struct _unused {};
    virtual void const *gen_data_p(kas_token const& tok
                                 , std::type_info const& info = typeid(_unused)
                                 , void const *obj            = nullptr
                                 ) const = 0;

    // calculate "expr" from token's `data_p` value
    virtual void gen_expr(expr_t& e, kas_token const&) const {};

    // return info about underlying token
    virtual bool is_fixed() const = 0;

    // test if token is particular type
    token_defn_base const *is_token_type(std::type_info const& info) const
    {
        // NB: warning generated by `typeid(get())`
        auto& t = get();
        return info == typeid(t) ? this : nullptr;
    }
#if 0
    // assign value from kas_object
    template <typename T, typename = std::enable_if_t<
                                        std::is_base_of_v<core::kas_object_tag, T>>>
    void set(kas_token&, T& obj);
    
    // assign value from floating point value
    void inline set(kas_token&, expression::detail::float_value<> flt);
#endif
};


// XXX new comment
// `token_defn_t` is currently a "final" type (eg: `get` method *must* be overridden)
// could be better if it was a CRTP base.
// NB: currently `gen_expr` overrides take place in `kas::parser` namespace. 
// Deriving from `token_defn_t` required redefining `get()` method: likely error.

// declared in `parser_types.h`
template <typename NAME, typename VALUE_T = void, typename PARSER = void>
struct token_defn_t : token_defn_base
{
    using base_t   = token_defn_base;
    using name_t   = NAME;
    using parser_t = PARSER;        // NB: iff parser is `type`

    // default `value_t` to x3::unused_type
    using value_t  = std::conditional_t<std::is_void_v<VALUE_T>
                                      , x3::unused_type
                                      , VALUE_T
                                      >;

    using type     = token_defn_t;  // for MPL usage

    // define for tokens parsed by `name`
    static kas_token (*parser)(kas_token const&);

    token_defn_t() = default;
   
    // ctor 
    token_defn_t(kas_token const& token) : token_p(&token) {}

    // bind "token" to definition (in the spirit of python)
    static token_defn_t bind(kas_token const& token)
    {
        return token_defn_t(token);
    }

    // true iff can generate `parser` from `token_defn_t`
    using has_parser = meta::bool_<!std::is_void_v<PARSER>>;

    base_t const& get() const override
    {
        // NB: `NAME` is not "literal type" per clang, thus not constexpr
        static const token_defn_t defn;
        return defn;
    }

    // true if bound instance of this type
    operator bool() const;
    
    // true iff token is `e_fixed_t`
    // NB: `e_fixed_t` undefined: use out-of-line definition
    bool is_fixed() const override;

    // defined in `kas_parser` (after `expr_t` defined)
    unsigned index() const override;
    
    const char *name() const override
    {
        return NAME();
    }

    // `expr_t` passed by reference because it's an incomplete type
    void gen_expr(expr_t& e, kas_token const& tok) const override;
    
    // method to retrieve & cast token `data` pointer
    // using `bound` instance of `token_defn_t`
    value_t const *operator()(kas_token const *p = {}) const;

private:
    friend kas_token;       // forward declared in `parser_types.h`

    // declare method to generate `data_p` from `string`
    void const *gen_data_p(kas_token const& tok
                         , std::type_info const& info
                         , void const *obj
                         ) const override;
    
    // for "bound" instance (in python parlance)
    kas_token const *token_p {};
};

}

#endif
