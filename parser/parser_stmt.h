#ifndef KAS_PARSER_INSN_H
#define KAS_PARSER_INSN_H

#include "expr/expr.h"
#include "kas_core/opcode.h"
#include "literal_parser.h"
#include "stmt_print.h"

#include <functional>

/*
 * Declare the statements used by the parser itself.
 *
 * These are the
 *
 * 1) "empty" stmt: `x3` requires stmt expose default type
 * 2) "eoi"   stmt: generated at end-of-input
 *
 * Also support the `print` module.
 * Provide indirection to `print_stmt` as required
 */


namespace kas::parser
{
namespace detail {
    using namespace meta;
    using boost::mpl::string;

    // vector of types in variant
    template <typename tag = void> struct parser_stmt_l : list<> {};

    // vector of rules for label
    template <typename tag = void> struct parser_label_l : list<> {};

    // declare empty strings for comment and stmt seperator default
    template <typename = void> struct stmt_separator_str : string<> {};
    template <typename = void> struct stmt_comment_str   : string<> {};

    // declare default "Parsers" for comment & stmt seperator
    // NB can't default "type", because that would instantiate
    // stmt_*_str templates
    template <typename INSN_SEPARATOR, typename = void>
    struct stmt_separator_p : literal_parser<INSN_SEPARATOR> {};

    template <typename INSN_COMMENT,   typename = void>
    struct stmt_comment_p   : literal_parser<INSN_COMMENT>   {};
}

using namespace ::kas::core::opc;

namespace print {
    template <typename OS, typename...Ts>
    void print_stmt(OS&, Ts&&...);
}

using print_fn = print::stmt_print<std::ostream>;
struct parser_stmt : kas_position_tagged
{
    // static functions which generate & print insns
    struct vtable
    {
        const char *(*name)();
        opcode& (*gen_insn)(opcode::Inserter&, opcode::fixed_t&, opcode::op_size_t&);
        void (*print_args)(print_fn&);
    };

    parser_stmt()
    {
        //std::cout << "parser_stmt: default_ctor" << std::endl;
    }
    
    parser_stmt(vtable const &vt) : vptr(&vt)
    {
        //std::cout << "parser_stmt: vtable_ctor" << std::endl;
    }
    
    // interface to insn: call operator() generates insn
    template <typename...Ts>
    opcode& operator()(Ts&&...);

    // interface to insn: ostream& operator<< prints
    template <typename OS>
    friend OS& operator<<(OS& os, parser_stmt&);
    
private:
    static const char *_name() { return "*UNINIT*"; }
    static constexpr vtable vtable_default = { _name };

    vtable const *vptr = &vtable_default;
};

template <typename DERIVED, typename OPCODE = opc_nop<>>
struct insn_stmt : parser_stmt
{
    using opcode_t  = OPCODE;
    using derived_t = DERIVED;

    insn_stmt() : parser_stmt(vt) {}
    
    // declare out-of-line static methods
    static auto& get_opcode();
    static auto  get_args();
    static const char *name();
    static void print_args(print_fn& fn);
    static opcode& gen_insn(opcode::Inserter& di
                    , opcode::fixed_t& fixed
                    , opcode::op_size_t& size);
    
private:
    static constexpr vtable vt
            { derived_t::name, derived_t::gen_insn, derived_t::print_args };
};

// default values for opcode/args
template <typename DERIVED, typename OPCODE>
auto& insn_stmt<DERIVED, OPCODE>::get_opcode()
{
    static opcode_t opc;
    return opc;
}

template <typename DERIVED, typename OPCODE>
auto insn_stmt<DERIVED, OPCODE>::get_args()
{
    return std::tuple<>{};
}

template <typename DERIVED, typename OPCODE>
const char *insn_stmt<DERIVED, OPCODE>::name()
{
    return derived_t::get_opcode().name();
}

template <typename DERIVED, typename OPCODE>
void insn_stmt<DERIVED, OPCODE>::print_args(print_fn& fn)
{
    std::apply(fn, derived_t::get_args());
}

template <typename DERIVED, typename OPCODE>
opcode& insn_stmt<DERIVED, OPCODE>::gen_insn(opcode::Inserter& di
                , opcode::fixed_t& fixed
                , opcode::op_size_t& size)
{
    auto& opc = derived_t::get_opcode();
    opc.init(fixed, size);

    auto proc_args = [&](auto&&...args)
        {
            opc.proc_args(di, std::forward<decltype(args)>(args)...);
        };
    std::apply(proc_args, derived_t::get_args());
    return opc;
}

////////////////////////////////////////////////////////////////////////
//
// statments generated by parser
//
////////////////////////////////////////////////////////////////////////

struct stmt_empty : insn_stmt<stmt_empty , opc_nop<>> {};
struct stmt_eoi   : insn_stmt<stmt_eoi   , opc_nop<KAS_STRING("EOI")>> {};
struct stmt_error : insn_stmt<stmt_error , opc_error>
{
    static inline kas_error_t diag;
    
    stmt_error(kas_error_t diag)
    {
        this->diag = diag;
    }

    static auto get_args()
    {
        return std::forward_as_tuple(diag);
    }
};

namespace detail {
    template<> struct parser_stmt_l<defn_expr> : list<
        //  stmt_empty        // default value for variant
        // stmt_eoi
        // stmt_error
           parser_stmt
        > {};
}

}


#endif
