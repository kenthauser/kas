#ifndef KAS_PARSER_PARSER_STMT_H
#define KAS_PARSER_PARSER_STMT_H

#include "expr/expr.h"
#include "kas_loc.h"
#include "kas_token.h"
#include "stmt_print.h"
#include "kas_core/opcode.h"

#include <boost/mpl/string.hpp>
#include <functional>

/*
 * Declare the statements used by the parser itself.
 *
 * These are the
 *
 * 1) "empty" stmt: `x3` requires stmt expose default type
 * 2) "eoi"   stmt: generated at end-of-input
 *
 * Also support the `print` module.
 * Provide indirection to `print_stmt` as required`
 */


namespace kas::parser
{
namespace detail
{
    using namespace meta;

    // vector of types in variant
    template <typename tag = void> struct parser_type_l : list<> {};

    // vector of rules for statments 
    template <typename tag = void> struct parser_stmt_l : list<> {};

    // vector of rules for label
    template <typename tag = void> struct parser_label_l : list<> {};

    // declare empty strings for comment and stmt seperator default
    template <typename = void> struct stmt_separator_str : kas_string<> {};
    template <typename = void> struct stmt_comment_str   : kas_string<> {};
}

using namespace ::kas::core::opc;

namespace print
{
    template <typename OS, typename...Ts>
    void print_stmt(OS&, Ts&&...);
}


using print_obj = print::stmt_print<std::ostream>;

template <typename Derived>
struct parser_stmt //: kas_position_tagged
{
    using base_t    = parser_stmt<Derived>;
    using derived_t = Derived;
    using print_obj = print::stmt_print<std::ostream>;
    using opcode    = core::opcode;

    // CRTP casts
    auto& derived() const
        { return *static_cast<derived_t const*>(this); }
    auto& derived()
        { return *static_cast<derived_t*>(this); }

    // primary entrypoints:
    const char *name() const
    {
        return "STMT";
    }

    void  print_args(print_obj const&) const
    {
        // no args
    }

    // NB: must be implemented in `Derived`
    opcode *gen_insn(opcode::data_t& data);
};

////////////////////////////////////////////////////////////////////////
//
// statments generated by parser:
//
// 1. `nop`  stmt (nop or eoi)
// 2. `diag` stmt (diagnostic)
//
////////////////////////////////////////////////////////////////////////

namespace detail
{
    template <typename OPC>
    struct stmt_nop : parser_stmt<stmt_nop<OPC>>
    {
        using base_t = typename parser_stmt<stmt_nop<OPC>>::base_t;
        
        // w/o braces, clang drops core on name(). 2019/02/15 KBH
        static inline OPC opc{};

        // inherit default ctor
        using base_t::base_t;
        
        const char *name() const
        {
            return opc.name();
        }

        opcode *gen_insn(core::opcode_data& data)
        {
            return &opc;
        }
    };
    
    struct stmt_diag : parser_stmt<stmt_diag>
    {
        using base_t = parser_stmt;
        
        // w/o braces, clang drops core on name(). 2019/02/15 KBH
        static inline opc_error opc{};
    
        using base_t::base_t;
        
        stmt_diag(kas_error_t diag)
            : diag(diag) {}
        
        stmt_diag(kas_diag_t const& err) : stmt_diag(err.ref()) {}
       
        stmt_diag(kas_token const& token)
        {
            diag = kas_diag_t::error("Invalid instruction", token).ref();
        }
        
        const char *name() const
        {
            return opc.name();
        }

        void print_args(typename base_t::print_obj const& p_obj) const
        {
            p_obj(diag);
        }

        opcode *gen_insn(core::opcode_data& data)
        {
            // fixed area unused otherwise...
            data.fixed.diag = diag;
            return &opc;
        }
        
        kas_error_t diag;
    };
}

using stmt_empty = detail::stmt_nop<opc_nop<>>;
using stmt_eoi   = detail::stmt_nop<opc_nop<KAS_STRING("EOI")>>;
using stmt_error = detail::stmt_diag;


namespace detail
{
    // stmts defined by parser
    template<> struct parser_type_l<defn_parser> : list<
          stmt_empty        // default value for variant
        , stmt_eoi          // end-of-input
        , stmt_error        // undefined instruction
        > {};
}

}


#endif
