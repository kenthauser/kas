Desire: have all `expr` arguments be `kas_token`.


Parser Tokens


1. kas_token has `kas_position_tagged` base. And supports `operator std::string()`

2. kas_token also needs pure `virtual expr_t operator() const`

3. need template with value_t & parser_t to return x3 parser.

4. how to handle `expr()` parser. Since derived types may have state (ie ref, or in
   case of `token_local_ident` other values), can't just use `kas_token`. Probably
   need new class of `expr, kas_token` tuple for expr. Solves problem of no 
   `token` for integral types

5. Probably need eval parser (instead of defer string eval) for reg_t, insn_t, e_fixed_t, etc.

6. registers: the register value only is stored if `reg_t` (ie no location value).
   just use "kas_token" base class for location

7. expression:: must add "locations" when performing calculations

******************

Token elements:

1. derived from `kas_position_tagged`

2. has `operator expr_t() const` method

3. has `value_type` template template

4. has `parser_t`   paramater (typename?)

5. has method to identify token type (string, bsd_at_string, bsd_at_num, missing, etc)

6. bonus: token name


for BSD: examples of current `token` usage:

// parser @ "tokens" (used by ELF)
auto const at_token_initial = omit[char_("@%#")];
auto const at_ident = token<token_at_ident>[(at_token_initial >> !digit) > +bsd_charset];
auto const at_num   = token<token_at_num>  [ at_token_initial >   uint_  > !bsd_charset];


template <typename VALUE_T = void, typename FMT = void>
XXX_token : kas_position_tagged
{
    static constexpr bool has_value = !std::is_void_v<VALUE_T>;

    operator std::string() const
    {
        return { first, last };
    }

    operator expr_t() const 
    {
        if constexpr (has_value)
        {
            static constexpr inline FMT_T fmt;
            if (expr.empty())
                expr = fmt.gen_expr(*this);
        }
        return expr;
    }

private:
    expr_t expr;
}


********************

Since `kas_token` has an `expr` member, it can not be defined until after `expr_t` defined,
which means after all component types have been defined. Also, a `x3::rule` which has
`kas_token` as value-type can't be defined until `expr_t` defined.

Solution: define `parser` as meta::list with elements:

    1) "name" (a kas::k_string)
    2) "parsed token type" (eg: core::addr_ref, or expr::e_fixed_t. defaults to void)
    3) "x3::parser" (defaults to void, may be inferred from token_type, can be assigned using `[]`

1. Refactor expr_parser to define parsers from tuple.

2. Refactor expr_parser to expect/return `kas_token`. 

3. Refactor `bsd_parser` to use `kas_token` as `bsd_arg`

4. Refactor tgt_parser to use `kas_token`

*****

Refactor plan:

1) create `X_kas_token` for new style. Allow `kas_token` to remain unchanged. (Used as
   base class for `tgt_arg_t`). Create metafunction to create `rule` from tuple.

2) refactor `dot_parser_x3` et. al. to return `kas_token`. Should be compatible with expression
   parser evaluator. Problem: SPIRIT_DECLARE instantiates & don't have defn of `expr_t`.
   Initially just remove from `term_parsers_v` & delete `SPIRIT_DECLARES`

   NB: `SPIRIT_DECLARE` seems to just declare function with `Attribute&` argument.

3) be aware of token slicing problems.
    - If `parsed value` is int, init `kas_token._expr`
    - If `parsed value` is x3::raw, use to override `kas_position`
    - If `parsed value` is register, derive a `token_defn` instance for *each* register
    * all other `parsed tokens` should use `string` to init value
    

3) create `tuples` for tokens. Create metafunction to create `rules`. Convert bsd_arg to
    X_token. clean up compile errors.

4) re-expose `dot_parser_x3` et. al. to `kas_token` variant. back to base operator.

5) change `tgt_arg` etc to X_token. Including `tgt_reg_t`

6) change fixed/float to `X_token`. Support combining `position_tag` in expr_op.

7) refactor `terminals` etc defns to use tpls. 

8) rename X_kas_token -> kas_token.

...cleanup...

9) refactor `boost::mpl::string<X>` comment strings to `KAS_STRING("X")`

10) `using namespace parser` in parser sub-namespaces. Delete "x3 = ..." references.


